#define CPP_CLI_DLL

#include "{{ c.Name }}.h"

#include <xstring>
#include <msclr\marshal.h>
#include <msclr\marshal_cppstd.h>



////////////////////// Constructors //////////////////////
{% for con in c.Constructors -%}
{{ c.Name }}I* {{ c.Name }}I::New{{ c.Name }}({% parameters con.Parameters %})
{
	return new {{ c.Name }}CPP(gcnew {{ c.Name }}({% parametersCall con.Parameters %}));
}

{% endfor -%}

////////////////////// Static Functions //////////////////////
{% for fun in c.StaticFunctions -%}
{{ fun.ReturnType }} {{ c.Name }}I::{{ fun.Name }}({% parameters fun.Parameters %})
{
	try
	{
{% if fun.IsVoidReturn == false -%}
		{{ fun.ReturnManagedType }} _res = {{ c.Name }}::{{ fun.Name }}({% parametersCall fun.Parameters %});
		return {{ fun.ReturnName }};
{% else -%}
		{{ c.Name }}::{{ fun.Name }}({% parametersCall fun.Parameters %});
{% endif -%}
	}
	catch (System::Exception^ e)
	{
		std::string msg = msclr::interop::marshal_as<std::string>(e->Message);
		throw std::exception(msg.c_str());		
	}
}

{% endfor -%}




////////////////////// Propeties //////////////////////
{% for fun in c.Properties -%}
{{ fun.NativeType }} {{ c.Name }}CPP::Get{{ fun.Name }}()
{
	return m_{{ c.Name }}->{{ fun.Name }};
}

void {{ c.Name }}CPP::Set{{ fun.Name }}({{ fun.NativeType }} _Value)
{
	m_{{ c.Name }}->{{ fun.Name }} = {{ fun.SetName }};
}

{% endfor -%}

////////////////////// Functions //////////////////////
{% for fun in c.Functions -%}
{{ fun.ReturnType }} {{ c.Name }}CPP::{{ fun.Name }}({% parameters fun.Parameters %})
{
	try
	{
{% if fun.IsVoidReturn == false -%}
		{{ fun.ReturnManagedType }} _res = m_{{ c.Name }}->{{ fun.Name }}({% parametersCall fun.Parameters %});
		return {{ fun.ReturnName }};
{% else -%}
		{{ c.Name }}::{{ fun.Name }}({% parametersCall fun.Parameters %});
{% endif -%}
	}
	catch (System::Exception^ e)
	{
		std::string msg = msclr::interop::marshal_as<std::string>(e->Message);
		throw std::exception(msg.c_str());		
	}
}

{% endfor -%}
